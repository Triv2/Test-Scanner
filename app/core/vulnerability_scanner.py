import socket
import ssl
import re
import time
from typing import Dict, List, Optional, Tuple
import json
import os
import sys

from app.core.logger import Logger
from app.core.service_detector import ServiceDetector

class VulnerabilityScanner:
    """Scans for common vulnerabilities based on detected services"""
    
    def __init__(self):
        self.logger = Logger()
        self.service_detector = ServiceDetector()
        self.timeout = 3
        self._load_vulnerability_database()
    
    def _load_vulnerability_database(self):
        """Load vulnerability database from JSON file"""
        try:
            # Determine the application directory
            if getattr(sys, 'frozen', False):
                app_dir = os.path.dirname(sys.executable)
            else:
                app_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            
            db_path = os.path.join(app_dir, 'data', 'vulnerabilities.json')
            
            if os.path.exists(db_path):
                with open(db_path, 'r') as f:
                    self.vuln_db = json.load(f)
            else:
                self.logger.warning(f"Vulnerability database not found at {db_path}")
                self.vuln_db = {
                    "service_vulnerabilities": {},
                    "version_vulnerabilities": {},
                    "cve_details": {}
                }
        except Exception as e:
            self.logger.error(f"Error loading vulnerability database: {str(e)}")
            self.vuln_db = {
                "service_vulnerabilities": {},
                "version_vulnerabilities": {},
                "cve_details": {}
            }
    
    def scan_for_vulnerabilities(self, ip: str, port: int, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """
        Scan for vulnerabilities based on service information
        
        Args:
            ip: Target IP address
            port: Target port number
            service_info: Service information dictionary from ServiceDetector
            
        Returns:
            List of vulnerability dictionaries
        """
        vulnerabilities = []
        
        # Get service name and version
        service = service_info.get('service', 'unknown')
        version = service_info.get('version', '')
        
        # Check for known service vulnerabilities
        service_vulns = self._check_service_vulnerabilities(service)
        vulnerabilities.extend(service_vulns)
        
        # Check for version-specific vulnerabilities
        if version:
            version_vulns = self._check_version_vulnerabilities(service, version)
            vulnerabilities.extend(version_vulns)
        
        # Perform service-specific checks
        if service == 'http' or service == 'https':
            web_vulns = self._check_web_vulnerabilities(ip, port, service == 'https')
            vulnerabilities.extend(web_vulns)
        elif service == 'ssh':
            ssh_vulns = self._check_ssh_vulnerabilities(ip, port, service_info)
            vulnerabilities.extend(ssh_vulns)
        elif service == 'ftp':
            ftp_vulns = self._check_ftp_vulnerabilities(ip, port, service_info)
            vulnerabilities.extend(ftp_vulns)
        elif service == 'smtp':
            smtp_vulns = self._check_smtp_vulnerabilities(ip, port, service_info)
            vulnerabilities.extend(smtp_vulns)
        elif service == 'mysql' or service == 'postgresql' or service == 'mssql':
            db_vulns = self._check_database_vulnerabilities(ip, port, service, service_info)
            vulnerabilities.extend(db_vulns)
        elif service == 'rdp':
            rdp_vulns = self._check_rdp_vulnerabilities(ip, port, service_info)
            vulnerabilities.extend(rdp_vulns)
        elif service == 'smb':
            smb_vulns = self._check_smb_vulnerabilities(ip, port, service_info)
            vulnerabilities.extend(smb_vulns)
        
        # Remove duplicates while preserving order
        unique_vulns = []
        seen = set()
        for vuln in vulnerabilities:
            vuln_id = vuln.get('id', '') or vuln.get('name', '')
            if vuln_id not in seen:
                seen.add(vuln_id)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def _check_service_vulnerabilities(self, service: str) -> List[Dict[str, str]]:
        """Check for known vulnerabilities for a service"""
        vulnerabilities = []
        
        if service in self.vuln_db.get("service_vulnerabilities", {}):
            for vuln_id in self.vuln_db["service_vulnerabilities"][service]:
                if vuln_id in self.vuln_db.get("cve_details", {}):
                    vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
        
        return vulnerabilities
    
    def _check_version_vulnerabilities(self, service: str, version: str) -> List[Dict[str, str]]:
        """Check for version-specific vulnerabilities"""
        vulnerabilities = []
        
        # Check if service exists in version vulnerabilities
        if service in self.vuln_db.get("version_vulnerabilities", {}):
            service_versions = self.vuln_db["version_vulnerabilities"][service]
            
            # Check each version pattern
            for version_pattern, vuln_ids in service_versions.items():
                # Convert version pattern to regex
                if version_pattern.startswith("<="):
                    # Handle less than or equal
                    pattern_version = version_pattern[2:]
                    if self._compare_versions(version, pattern_version) <= 0:
                        for vuln_id in vuln_ids:
                            if vuln_id in self.vuln_db.get("cve_details", {}):
                                vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
                
                elif version_pattern.startswith("<"):
                    # Handle less than
                    pattern_version = version_pattern[1:]
                    if self._compare_versions(version, pattern_version) < 0:
                        for vuln_id in vuln_ids:
                            if vuln_id in self.vuln_db.get("cve_details", {}):
                                vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
                
                elif version_pattern.startswith(">="):
                    # Handle greater than or equal
                    pattern_version = version_pattern[2:]
                    if self._compare_versions(version, pattern_version) >= 0:
                        for vuln_id in vuln_ids:
                            if vuln_id in self.vuln_db.get("cve_details", {}):
                                vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
                
                elif version_pattern.startswith(">"):
                    # Handle greater than
                    pattern_version = version_pattern[1:]
                    if self._compare_versions(version, pattern_version) > 0:
                        for vuln_id in vuln_ids:
                            if vuln_id in self.vuln_db.get("cve_details", {}):
                                vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
                
                elif "-" in version_pattern:
                    # Handle range (e.g., "2.0.0-2.5.0")
                    lower, upper = version_pattern.split("-", 1)
                    if (self._compare_versions(version, lower) >= 0 and 
                        self._compare_versions(version, upper) <= 0):
                        for vuln_id in vuln_ids:
                            if vuln_id in self.vuln_db.get("cve_details", {}):
                                vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
                
                else:
                    # Exact version match
                    if version == version_pattern:
                        for vuln_id in vuln_ids:
                            if vuln_id in self.vuln_db.get("cve_details", {}):
                                vulnerabilities.append(self.vuln_db["cve_details"][vuln_id])
        
        return vulnerabilities
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        """
        Compare two version strings
        
        Returns:
            -1 if version1 < version2
            0 if version1 == version2
            1 if version1 > version2
        """
        try:
            # Extract numeric parts
            v1_parts = [int(x) for x in re.findall(r'\d+', version1)]
            v2_parts = [int(x) for x in re.findall(r'\d+', version2)]
            
            # Compare each part
            for i in range(min(len(v1_parts), len(v2_parts))):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            
            # If all parts are equal, compare lengths
            if len(v1_parts) < len(v2_parts):
                return -1
            elif len(v1_parts) > len(v2_parts):
                return 1
            else:
                return 0
        except Exception:
            # Fall back to string comparison if parsing fails
            if version1 < version2:
                return -1
            elif version1 > version2:
                return 1
            else:
                return 0
    
    def _check_web_vulnerabilities(self, ip: str, port: int, is_https: bool) -> List[Dict[str, str]]:
        """Check for web server vulnerabilities"""
        vulnerabilities = []
        
        # Get HTTP headers
        headers = self.service_detector.get_http_headers(ip, port, is_https)
        
        # Check for missing security headers
        security_headers = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'Content-Security-Policy',
            'X-XSS-Protection',
            'Strict-Transport-Security'
        ]
        
        missing_headers = []
        for header in security_headers:
            if header not in headers:
                missing_headers.append(header)
        
        if missing_headers:
            vulnerabilities.append({
                'id': 'MISSING_SECURITY_HEADERS',
                'name': 'Missing Security Headers',
                'description': f'The web server is missing the following security headers: {", ".join(missing_headers)}',
                'severity': 'Medium',
                'recommendation': 'Configure the web server to include these security headers'
            })
        
        # Check for server information disclosure
        if 'Server' in headers and headers['Server']:
            if len(headers['Server']) > 3:  # Not just a generic value
                vulnerabilities.append({
                    'id': 'SERVER_INFO_DISCLOSURE',
                    'name': 'Server Information Disclosure',
                    'description': f'The web server is revealing its software and version: {headers["Server"]}',
                    'severity': 'Low',
                    'recommendation': 'Configure the web server to hide detailed version information'
                })
        
        # Check for SSL/TLS issues if HTTPS
        if is_https:
            ssl_info = self.service_detector._get_ssl_info(ip, port)
            if ssl_info:
                # Check for weak SSL/TLS versions
                if ssl_info.get('version') in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                    vulnerabilities.append({
                        'id': 'WEAK_SSL_TLS',
                        'name': 'Weak SSL/TLS Version',
                        'description': f'The server is using an outdated SSL/TLS version: {ssl_info.get("version")}',
                        'severity': 'High',
                        'recommendation': 'Configure the server to use TLSv1.2 or TLSv1.3 only'
                    })
        
        # Check for common web vulnerabilities
        web_content = self.service_detector._get_web_content(ip, port, is_https)
        if web_content:
            # Check for potential SQL injection points
            if re.search(r'id=\d+|page=\w+|query=\w+', web_content):
                vulnerabilities.append({
                    'id': 'POTENTIAL_SQL_INJECTION',
                    'name': 'Potential SQL Injection Points',
                    'description': 'The web application contains URL parameters that might be vulnerable to SQL injection',
                    'severity': 'Medium',
                    'recommendation': 'Implement proper input validation and parameterized queries'
                })
            
            # Check for potential XSS vulnerabilities
            if re.search(r'<input|<textarea|<form', web_content):
                vulnerabilities.append({
                    'id': 'POTENTIAL_XSS',
                    'name': 'Potential Cross-Site Scripting (XSS) Vulnerabilities',
                    'description': 'The web application contains input fields that might be vulnerable to XSS attacks',
                    'severity': 'Medium',
                    'recommendation': 'Implement proper output encoding and Content-Security-Policy'
                })
        
        return vulnerabilities
    
    def _check_ssh_vulnerabilities(self, ip: str, port: int, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """Check for SSH vulnerabilities"""
        vulnerabilities = []
        banner = service_info.get('banner', '')
        
        # Check for weak SSH versions
        if 'SSH-1' in banner:
            vulnerabilities.append({
                'id': 'WEAK_SSH_VERSION',
                'name': 'Weak SSH Protocol Version',
                'description': 'The server is using SSH protocol version 1, which has known security issues',
                'severity': 'High',
                'recommendation': 'Configure the server to use SSH protocol version 2 only'
            })
        
        # Check for weak ciphers (would require more detailed probing)
        
        return vulnerabilities
    
    def _check_ftp_vulnerabilities(self, ip: str, port: int, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """Check for FTP vulnerabilities"""
        vulnerabilities = []
        banner = service_info.get('banner', '')
        
        # Check for anonymous FTP access
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(self.timeout)
                s.connect((ip, port))
                
                # Read banner
                s.recv(1024)
                
                # Try anonymous login
                s.send(b'USER anonymous\r\n')
                response = s.recv(1024)
                
                s.send(b'PASS anonymous@example.com\r\n')
                response = s.recv(1024)
                
                if b'230' in response:  # 230 = User logged in
                    vulnerabilities.append({
                                                'id': 'ANONYMOUS_FTP',
                        'name': 'Anonymous FTP Access',
                        'description': 'The FTP server allows anonymous access, which could expose sensitive files',
                        'severity': 'High',
                        'recommendation': 'Disable anonymous FTP access unless specifically required'
                    })
        except Exception:
            pass
        
        # Check for clear text FTP (not FTPS)
        if not service_info.get('encrypted', False):
            vulnerabilities.append({
                'id': 'CLEARTEXT_FTP',
                'name': 'Unencrypted FTP',
                'description': 'The FTP server is using unencrypted communications, exposing credentials and data',
                'severity': 'Medium',
                'recommendation': 'Configure the server to use FTPS (FTP over SSL/TLS)'
            })
        
        return vulnerabilities
    
    def _check_smtp_vulnerabilities(self, ip: str, port: int, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """Check for SMTP vulnerabilities"""
        vulnerabilities = []
        banner = service_info.get('banner', '')
        
        # Check for open relay
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(self.timeout)
                s.connect((ip, port))
                
                # Read banner
                s.recv(1024)
                
                # HELO command
                s.send(b'HELO test.com\r\n')
                s.recv(1024)
                
                # MAIL FROM
                s.send(b'MAIL FROM: <test@test.com>\r\n')
                response = s.recv(1024)
                
                if b'250' in response:  # 250 = OK
                    # RCPT TO (external domain)
                    s.send(b'RCPT TO: <test@example.com>\r\n')
                    response = s.recv(1024)
                    
                    if b'250' in response:  # Server accepted external recipient
                        vulnerabilities.append({
                            'id': 'SMTP_OPEN_RELAY',
                            'name': 'SMTP Open Relay',
                            'description': 'The SMTP server appears to be configured as an open relay, which can be abused for sending spam',
                            'severity': 'Critical',
                            'recommendation': 'Configure the SMTP server to reject unauthorized relay attempts'
                        })
        except Exception:
            pass
        
        # Check for STARTTLS support
        if not service_info.get('encrypted', False):
            vulnerabilities.append({
                'id': 'SMTP_NO_STARTTLS',
                'name': 'SMTP Without STARTTLS',
                'description': 'The SMTP server does not support STARTTLS encryption, exposing email contents and credentials',
                'severity': 'Medium',
                'recommendation': 'Configure the SMTP server to support STARTTLS'
            })
        
        return vulnerabilities
    
    def _check_database_vulnerabilities(self, ip: str, port: int, service: str, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """Check for database vulnerabilities"""
        vulnerabilities = []
        
        # Check for default credentials (would require actual login attempts)
        # This is a placeholder for a more sophisticated check
        vulnerabilities.append({
            'id': f'{service.upper()}_DEFAULT_CREDS_CHECK',
            'name': f'{service.capitalize()} Default Credentials Check',
            'description': f'The {service.upper()} database should be checked for default or weak credentials',
            'severity': 'Medium',
            'recommendation': f'Ensure {service.capitalize()} is using strong, non-default credentials'
        })
        
        # Check for unencrypted database connections
        if not service_info.get('encrypted', False):
            vulnerabilities.append({
                'id': f'{service.upper()}_UNENCRYPTED',
                'name': f'Unencrypted {service.capitalize()} Connection',
                'description': f'The {service.capitalize()} database is accepting unencrypted connections',
                'severity': 'Medium',
                'recommendation': f'Configure {service.capitalize()} to require encrypted connections'
            })
        
        # Check for public database access
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(self.timeout)
                s.connect((ip, port))
                
                # If we can connect from our IP, the database might be publicly accessible
                vulnerabilities.append({
                    'id': f'{service.upper()}_PUBLIC_ACCESS',
                    'name': f'Publicly Accessible {service.capitalize()} Database',
                    'description': f'The {service.capitalize()} database appears to be accessible from external networks',
                    'severity': 'High',
                    'recommendation': f'Restrict {service.capitalize()} access to trusted IP addresses only'
                })
        except Exception:
            pass
        
        return vulnerabilities
    
    def _check_rdp_vulnerabilities(self, ip: str, port: int, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """Check for RDP vulnerabilities"""
        vulnerabilities = []
        
        # Check for NLA (Network Level Authentication)
        # This would require more sophisticated RDP protocol handling
        # For now, we'll just add a placeholder recommendation
        vulnerabilities.append({
            'id': 'RDP_NLA_CHECK',
            'name': 'RDP Network Level Authentication Check',
            'description': 'RDP should be configured to use Network Level Authentication (NLA)',
            'severity': 'Medium',
            'recommendation': 'Enable Network Level Authentication for RDP connections'
        })
        
        # Check for weak encryption
        if service_info.get('version', '') and 'encryption: low' in service_info.get('version', '').lower():
            vulnerabilities.append({
                'id': 'RDP_WEAK_ENCRYPTION',
                'name': 'RDP Weak Encryption',
                'description': 'The RDP server is configured with weak encryption settings',
                'severity': 'High',
                'recommendation': 'Configure RDP to use high encryption levels'
            })
        
        return vulnerabilities
    
    def _check_smb_vulnerabilities(self, ip: str, port: int, service_info: Dict[str, str]) -> List[Dict[str, str]]:
        """Check for SMB vulnerabilities"""
        vulnerabilities = []
        version = service_info.get('version', '')
        
        # Check for SMBv1
        if 'SMBv1' in version or 'SMB 1.0' in version:
            vulnerabilities.append({
                'id': 'SMB_V1_ENABLED',
                'name': 'SMBv1 Protocol Enabled',
                'description': 'The server has SMBv1 protocol enabled, which is vulnerable to various attacks including EternalBlue',
                'severity': 'Critical',
                'recommendation': 'Disable SMBv1 protocol and use SMBv3 with encryption'
            })
        
        # Check for anonymous access
        try:
            # This would require actual SMB protocol implementation
            # For now, just a placeholder
            pass
        except Exception:
            pass
        
        # Check for guest access
        # This would require actual SMB protocol implementation
        
        return vulnerabilities